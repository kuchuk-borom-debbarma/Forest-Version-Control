
# ğŸŒ² FVC â€” Repository Design

*Independent Local Repositories Before Joining a Tree (Forest)*

In **Forest Version Control (FVC)**, a **repository** begins its life as a completely self-contained local version-control unit. It has **no awareness of hierarchy**, **no dependence on any other repo**, and maintains its own internal commit history and object store.

A repository only becomes part of a **Tree** (a hierarchical structure managed by central storage) *after* it is explicitly promoted and linked. Until then:

* It is independent
* It maintains its own `.fvc` directory
* It stores all of its objects locally
* It does not track or acknowledge child repos
* Nested repositories are automatically ignored

This section describes how **standalone FVC repositories** work internally.

---

# ğŸ“ Repository Folder Structure

After initialization, a repository has the following structure:

```
repo/
  .fvc/
    metadata.bin        # binary-encoded repository metadata
    HEAD                # pointer to the latest commit hash
    objects/            # blobs, trees, commit objects (content-addressed)
```

Nothing in this repository depends on anything external.
It behaves exactly like a small, clean, standalone VCS.

---

# ğŸš€ 1. Initializing a Repository

### Command

```
fvc init --name <repoName> --author <authorName?>
```

### Rules

* `--name` is **required**
* `--author` is optional (defaults to `"unknown"`)
* Repository names must be **unique within a central storage** *only if* they later join a Tree
  (Before that, name uniqueness does not matter.)
* Initialized repositories are **local-first** and **independent**.

### What Happens Internally

Running `fvc init` performs these actions:

#### âœ” 1. Creates the `.fvc` folder

The private home of the repository.

#### âœ” 2. Creates `metadata.bin`

A binary file storing:

* Repository name
* Author
* Description (optional / empty)
* Created timestamp
* Any future metadata fields

#### âœ” 3. Creates the `HEAD` file

Initially set to:

```
null
```

until the first commit is made.

#### âœ” 4. Creates the `objects/` directory

This will store:

* **Blob objects** (file contents)
* **Tree objects** (directories)
* **Commit objects**

All are stored using **content-addressed hashing**, meaning:

> the filename *is the hash* of the object's content.

---

# ğŸ§± 2. Creating Commits

### Command

```
fvc commit --message "..." --author "..." --files "file1,file2,*"
```

### File Selection Behavior

FVC supports flexible file selection:

#### Option A â€” Specify files explicitly:

```
--files "a.txt,src/main.go,config.json"
```

#### Option B â€” Track everything using `"*"`:

```
--files "*"
```

Rules for `"*"`:

* Means â€œall files in the working directoryâ€
* Excludes anything listed in `.gitignore`
* Excludes any nested `.fvc` repositories
* `"*"` cannot be combined with explicit paths

---

# ğŸ§© Commit Creation Process

When `fvc commit` is executed:

## ğŸ” 1. Scan Working Directory

* Include all selected files
* Exclude ignored patterns
* Exclude nested FVC repositories entirely

## ğŸ”¢ 2. Compute Blob Hashes

For each file:

1. Read its content
2. Compute its hash
3. Store the file in:

```
objects/<first_two_hex>/<rest_of_hash>
```

(Directory sharding prevents large directories.)

> Blob hashes guarantee deduplication: identical content = identical file object.

## ğŸŒ³ 3. Build Tree Objects (Directories)

FVC builds directory trees **bottom-up**.

For each directory:

```
tree {
  entries: [
    {
      name: string,
      type: BLOB | TREE,
      hash: string
    }
  ]
}
```

Directories reference:

* file blobs
* child tree objects

Tree objects also use content-addressed hashing.

## ğŸ§¾ 4. Create Commit Object

A commit object contains:

* `rootTreeHash`
* `parentCommitHash` (or `null`)
* `message`
* `author`
* `timestamp`

Serialized deterministically â†’ hashed â†’ stored in `objects/`.

## ğŸ”— 5. Update `HEAD`

The commit hash becomes the new HEAD:

```
HEAD = <commitHash>
```
