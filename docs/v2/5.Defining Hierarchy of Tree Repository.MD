
# ðŸŒ³Hierarchy of a Tree Repository

*Versioned Relationship Tracking Using Tree Objects*

Tree Storage not only holds linked repositories and their metadata but also maintains a complete, versioned representation of the **hierarchical relationships** between these repositories.
This hierarchy is modeled using immutable **Tree Objects**, which function similarly to commit objects.
Every change to the hierarchy produces a new Tree Object, allowing the structure to evolve while preserving its full historical record.

---

## 1 Purpose of the Hierarchy System

The hierarchy system defines *how repositories relate to each other* in a logical structure.
This model supports:

* parentâ€“child dependency relationships
* deep, multi-level structures
* scalable traversal and inspection
* complete historical tracking of structural evolution
* safe and immutable representation of relationships

The hierarchy is separate from commit history and does not affect the internal file versioning of individual repositories.

---

## 2 Tree Objects (Immutable Hierarchy Nodes)

Each node in the hierarchy is stored as a **Tree Object**.
A Tree Object describes a repository and its direct children at a specific moment in time.

Stored under:

```
tree_storage/.fvc/trees/<hash>
```

### Conceptual Structure

```json
{
  "treeID": "<repoID>",
  "children": [
    {
      "repoID": "childRepoA",
      "childTreeHash": "hash_of_child_tree"
    },
    {
      "repoID": "childRepoB",
      "childTreeHash": "hash_of_child_tree"
    }
  ],
  "parentTreeHash": "<previous_tree_hash_or_null>",
  "message": "Updated hierarchy",
  "author": "username",
  "timestamp": "2025-03-01T10:32:14Z"
}
```

### Key Properties

* **Immutable** â€” once written, never modified
* **Hash-identified** â€” ensures structural integrity
* **Linked** â€” each Tree Object references its previous version via `parentTreeHash`
* **Recursively defined** â€” children reference their own Tree Object hashes

Together, Tree Objects form a persistent, versioned Merkle-DAG of the entire system hierarchy.

---

## 3 Tree HEAD

The Tree Storage maintains a pointer to the latest version of the hierarchy:

```
tree_storage/.fvc/treeHEAD
```

This file contains the hash of the Tree Object that represents the **current root of the hierarchy**.

For example:

```
c2f9ab7e1e3f...
```

Whenever the hierarchy changes, `treeHEAD` is updated to refer to the newly created Tree Object.

---

## 4 Updating Relationships

Parentâ€“child relationships are defined and modified using commands such as:

```
fvc add-child --parent <path_to_repo> --child <child_paths>
fvc remove-child --parent <path_to_repo> --child <child_paths>
```

When a relationship update occurs:

1. The system resolves repository paths to their `repoID`s.
2. The existing Tree Object for the parent (referenced by treeHEAD) is loaded.
3. A modified Tree Object is created reflecting the structural change.
 The new Tree Object includes:

    * updated children list
    * `parentTreeHash` pointing to the previous version
    * metadata (author, timestamp, message)
5. The object is serialized, hashed, and stored.
6. `treeHEAD` is updated to point to this new Tree Object.

This guarantees that **every structural change is versioned**, easily traceable, and immutable.

---

## 5 Traversing the Hierarchy

Because Tree Objects reference:

* direct children
* each childâ€™s own Tree Object hash

the entire repository hierarchy can be traversed efficiently by recursively following these hashes.

Traversal begins at the hash stored in `treeHEAD` and expands outward through all child nodes.
This supports both full and partial exploration of the dependency graph.

---

## 6 Scalability

The versioned hierarchy model is designed for large-scale systems. It scales to:

* hundreds or thousands of repositories
* deep nesting
* frequent structural changes

Key scalability benefits:

* **Immutability** â€” unchanged subtrees reuse the same Tree Object
* **Hashing** â€” small updates produce minimal storage cost
* **Sparse updates** â€” only modified nodes generate new objects
* **Efficient graph traversal** â€” only relevant parts of the tree are explored
* **No global rewrite** â€” updates do not require reserializing the entire hierarchy

This ensures performance remains stable regardless of system size.

---

## 7 Summary

The hierarchy of a Tree Repository is represented using **versioned Tree Objects**, each describing the structure and relationships of a repository at a specific point in time.
Every hierarchy change results in a new Tree Object and an updated `treeHEAD`.
This design provides:

* full historical tracking
* immutability
* reproducibility
* scalability
* clean separation from commit history
