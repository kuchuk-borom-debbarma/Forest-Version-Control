
# ðŸŒŸ 5. Super Snap

*Full-Tree and Subtree Snapshotting of Versioned Repository Hierarchies*

Super Snap is a mechanism for creating **consistent, hierarchical snapshots** of repository states inside a Tree Storage.
While individual repositories maintain their own commit histories, Super Snap captures the **combined state** of a repository and all of its descendants (direct and indirect) at a specific point in time.

Each Super Snap operation generates a **snapshot tree**, composed of immutable Super Snap Objects, each corresponding to a repository within the snapshot scope.

This snapshot tree can be used to:

* reproduce the exact repository states at that moment
* restore entire subtrees
* maintain independent snapshot histories at any level
* analyze the evolution of subsystems or full systems

Super Snap is independent of commit history and independent of Tree hierarchy history.
It uses these systems but does not modify them.

---

# 5.1 Purpose of Super Snap

Super Snap provides:

### âœ” Consistent multi-repository versioning

Captures commit HEADs of all repositories in a subtree.

### âœ” Distributed snapshotting

Snapshots can be taken at any hierarchy level â€” root, intermediate, or leaf.

### âœ” Independent histories

Each repository maintains its own chain of super snap objects.

### âœ” Scalable hierarchical storage

Only direct childrenâ€™s snapshots are stored at each level, reducing duplication.

### âœ” Immutable snapshot trees

Each snapshot produces a Merkle-style object graph.

---

# 5.2 Super Snap Object Model

Super Snap creates one immutable object per repository being snapped.

Stored under:

```
tree_storage/.fvc/supersnaps/<repoID>/<hash>
```

Where `<hash>` is a content hash of the super snap object.

## Super Snap Object Structure (Conceptual)

```json
{
  "repoID": "uuid-1234",
  "commitHash": "abcd1234ef...",           
  "children": [
    {
      "repoID": "childRepoID1",
      "superSnapHash": "hash_of_child_supersnap"
    },
    {
      "repoID": "childRepoID2",
      "superSnapHash": "hash_of_child_supersnap"
    }
  ],
  "timestamp": "2025-03-02T12:10:44Z",
  "author": "John Doe",
  "message": "Snapshot of A and C",
  "previousSuperSnapHash": "hash_of_previous_supersnap_or_null"
}
```

### Fields Explained

| Field                   | Description                                         |
| ----------------------- | --------------------------------------------------- |
| `repoID`                | Repository identifier                               |
| `commitHash`            | Commit HEAD of this repo when snapshot was taken    |
| `children[]`            | Direct child repos + their super snap object hashes |
| `timestamp`             | Snapshot creation time                              |
| `author`                | Creator of the snapshot                             |
| `message`               | Optional message provided by user                   |
| `previousSuperSnapHash` | Pointer to previous snapshot of this repo           |

This structure creates:

* a **chain** of snapshots for each repository (like commit history)
* a **tree** of snapshots across all repos under the snapshot root

---

# 5.3 Storage Layout

Tree Storage organizes super snaps as:

```
.fvc/
  supersnaps/
    <repoID>/
      <hash1>
      <hash2>
      ...
```

For example:

```
.fvc/supersnaps/
  rootID/
    12ac98e...
    991db30...
  aID/
    003bc11...
    447aa11...
  cID/
    716df01...
```

Each file contains the serialized Super Snap Object.

---

# 5.4 Super Snap Generation Flow

Below is the complete algorithm performed when a user executes:

```
fvc super-snap --message "Snapshot XYZ"
```

### Step 1 â€” Identify Snapshot Root

Determine which repository the command is executed from.
Resolve it to its `repoID`.

### Step 2 â€” Load Current Hierarchy

Read the latest hierarchy state using:

```
treeHEAD â†’ latest Tree Object hash â†’ traverse to find all descendants
```

This gives the list of repositories under the snapshot scope.

### Step 3 â€” Recursively Snapshot All Descendants

For each repository in the subtree:

1. Retrieve its `HEAD` commit hash

2. Recursively process its child repositories

3. Generate a Super Snap Object:

    * `repoID`
    * `commitHash`
    * `children[]` (pointing to child super snap hashes)
    * `previousSuperSnapHash` (from supersnap/<repoID>/latest)
    * `metadata`

4. Hash it

5. Store under:

```
supersnaps/<repoID>/<hash>
```

### Step 4 â€” Return the Rootâ€™s Super Snap Hash

The final hash representing the snapshot is the Super Snap Object of the root repository where the command was run.

This hash represents the entire subtree snapshot.

---

# 5.5 Independent Per-Repository Super Snap Histories

Each repository has its own independent super snap timeline.

Example:

### Repository A:

```
a_snap_1 â†’ a_snap_2 â†’ a_snap_3
```

### Repository root:

```
root_snap_1 â†’ root_snap_2
```

### Repository B:

```
b_snap_1 â†’ b_snap_2
```

These chains are independent because snapshots occur at different hierarchy levels or times.

---

# 5.6 Multi-Level Snapshotting

Super Snap supports multi-level snapshot histories.

### Example Hierarchy:

```
root
 â”œâ”€ a
 â”‚   â””â”€ c
 â””â”€ b
```

### Scenario:

1. User runs `super-snap` at **A**

    * Stores A_HEAD and C_HEAD
    * Only A and C get snapshot entries

2. Later, user runs `super-snap` at **root**

    * Stores root_HEAD, A_HEAD, B_HEAD
    * Uses A's snapshot, which internally refers to C's snapshot

Thus, different levels can be snapped independently and coexist peacefully.

---

# 5.7 Snapshot Traversal

To reconstruct a snapshot:

1. Start at the super snap hash of the repository
2. Read its Super Snap Object
3. Restore:

    * its commitHash
    * its children recursively
4. Follow child pointers to restore deeper levels

This matches the hierarchical nature of the system and ensures consistency.

---

# 5.8 Summary

Super Snap provides:

* hierarchical, multi-repository snapshots
* immutable snapshot objects
* independent per-repository histories
* efficient Merkle-tree storage
* flexible snapshot levels
* consistent reconstruction of entire subtrees
